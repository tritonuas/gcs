package main

import (
	"github.com/namsral/flag"
	"os"
	"fmt"
	"github.com/sirupsen/logrus"
	//"github.com/kardianos/osext"
	"net"
	"net/http"

	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"github.com/rs/cors"
	//pb "github.com/tritonuas/protos/interop"
	"golang.org/x/net/context"
	"google.golang.org/grpc"

	interopconn "github.com/tritonuas/hub/internal/interopconn"
	missionedit "github.com/tritonuas/hub/internal/mission_edit"
	pathplan "github.com/tritonuas/hub/internal/path_plan"
	hub "github.com/tritonuas/hub/internal/hub_def"
	pb "github.com/tritonuas/hub/internal/interop"
	sim "github.com/tritonuas/hub/internal/sim"
	mav "github.com/tritonuas/hub/internal/mavlink"
	udp "github.com/tritonuas/hub/internal/udp"
	ws "github.com/tritonuas/hub/internal/websocket"
	utils "github.com/tritonuas/hub/internal/utils"
)

// var Log *logrus.Logger
var log = logrus.New()

var hub_addr = flag.String("hub_addr", "5001", "http service hub_address")
var hub_path = flag.String("hub_path", "/home/mat/gopath/src/github.com/tritonuas/hub", "Path to hub folder")
var interop_ip = flag.String("interop_ip", "127.0.0.1", "ip of interop computer")
var interop_port = flag.String("interop_port", "8000", "port of interop computer")
var interop_user = flag.String("interop_user", "ucsdauvsi", "username on interop computer")
var interop_pass = flag.String("interop_pass", "tritons", "password to interop computer")
var mav_device = flag.String("mav_device", ":5761", "mav device")
var ip = flag.String("ip", "*", "ip of interop computer")
var debug = flag.Bool("debug", false, "a bool")
var socket_addr = flag.String("socket_addr", "127.0.0.1:6667", "ip + port of path planner zmq")
var env_var = flag.Bool("env_var", false, "use environment variables")


func main() {
	flag.Parse()
	if *env_var {
		var env = os.Getenv("HUB_PATH")
		if len(env) > 0 {
			*hub_path = env
		}
		env = os.Getenv("INTEROP_IP")
		if len(env) > 0 {
			*interop_ip = env
		}
		env = os.Getenv("INTEROP_PORT")
		if len(env) > 0 {
			*interop_port = env
		}
		env = os.Getenv("INTEROP_USER")
		if len(env) > 0 {
			*interop_user = env
		}
		env = os.Getenv("MAV_DEVICE")
		if len(env) > 0 {
			*mav_device = env
		}
	}

	if *debug {
		log.SetLevel(logrus.DebugLevel)
	}

	interopconn.Log = log
	missionedit.Log = log
	hub.Log = log
	// Log.Info("MARCO")
	//_, _ := osext.ExecutableFolder()
	// log.Warning(*hub_path)
	missionfolder := utils.Get_path("", *hub_path, "/missions/")
	pathfolder := utils.Get_path("", *hub_path, "/paths/")
	swaggerfolder := utils.Get_path("", *hub_path, "/third_party/swagger-ui/")
	// log.Warning(missionfolder)
	sim.SetupHelpers(missionfolder)

	// log.Info("Starting Hub")

	cur_hub := hub.CreateHub()

	// Create Topics
	log.Info("Creating Topics: telemetry, plane_loc, plane_status")
	cur_hub.AddTopic("telemetry")
	cur_hub.AddTopic("plane_loc")
	cur_hub.AddTopic("plane_status")
	log.Info("Creating Topics: obstacle, mission_status, plane_obc_data")
	cur_hub.AddTopic("obstacle_data")
	cur_hub.AddTopic("mission_status")
	cur_hub.AddTopic("plane_obc_data")

	go mav.ListenAndServe(*mav_device, cur_hub.Topics["telemetry"], cur_hub.Topics["plane_loc"], cur_hub.Topics["plane_status"], *socket_addr)

	udp.CreateUDPBackend(cur_hub.Topics["plane_obc_data"], ":5555")

	mux := http.NewServeMux()

	mux.HandleFunc("/websocket/gcs", func(w http.ResponseWriter, r *http.Request) {
		ws.ServeWs(nil, cur_hub.Topics["mission_status"].Subscriber(100), cur_hub.Topics["plane_loc"].Subscriber(3), cur_hub.Topics["plane_status"].Subscriber(1),cur_hub.Topics["obstacle_data"].Subscriber(1), w, r)
	})

	mux.HandleFunc("/websocket/obc", func(w http.ResponseWriter, r *http.Request) {
		ws.ServeWs(cur_hub.Topics["plane_obc_data"].Subscriber(100), nil, nil, nil,nil, w, r)
	})

	// Log.Info("hello")

	swaggerassets := http.StripPrefix("/swagger/", http.FileServer(http.Dir(swaggerfolder)))
	mux.Handle("/swagger/", swaggerassets)
	log.Warn(fmt.Sprint("Interop IP + Port: ", string(*interop_ip), ":", *interop_port))
	// log.Info(*interop_port)
	log.Warn("Interop User: ", *interop_user)
	log.Warn("Interop Password: ", *interop_pass)
	mission_report := interopconn.CreateMissionReportFull("http://"+string(*interop_ip)+":"+*interop_port, *interop_user, *interop_pass, 1, cur_hub.Topics["telemetry"].Subscriber(100), cur_hub.Topics["mission_status"], cur_hub.Topics["obstacle_data"])

	// log.Info("continue")

	grpcServer := grpc.NewServer()
	pb.RegisterMissionEditServer(grpcServer, missionedit.CreateMissionEdit(missionfolder))
	pb.RegisterInteropServer(grpcServer, interopconn.CreateInteropServer(mission_report))
	log.Info(pathfolder)
	pb.RegisterPathPlannerServer(grpcServer, pathplan.CreatePathPlanServer(pathfolder, "192.168.1.8:6666"))

	ctx := context.Background()
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	gwmux := runtime.NewServeMux(runtime.WithMarshalerOption(runtime.MIMEWildcard, &runtime.JSONPb{OrigName: true, EmitDefaults: true}))

	mux.Handle("/", gwmux)
	dopts := []grpc.DialOption{grpc.WithInsecure()}
	err := pb.RegisterMissionEditHandlerFromEndpoint(ctx, gwmux, ":"+*hub_addr, dopts)
	err = pb.RegisterInteropHandlerFromEndpoint(ctx, gwmux, ":"+*hub_addr, dopts)
	err = pb.RegisterPathPlannerHandlerFromEndpoint(ctx, gwmux, ":"+*hub_addr, dopts)
	if err != nil {
		log.Info(err)
		return
	}

	log.Info("listen")

	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", 5001))
	if err != nil {
		log.Info("failed to listen: %v", err)
	}
	go grpcServer.Serve(lis)
	handler := cors.Default().Handler(mux)
	http.ListenAndServe(":5000", handler)

	log.Info("listen and serve")
	if err != nil {
		log.Info("error")
		log.Fatal("ListenAndServe: ", err)
	}
}
